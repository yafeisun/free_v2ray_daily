# 12小时定时测速策略实施说明

## 📅 调整内容

### 定时任务变更
- **原**: 无定时（依赖workflow_run触发）
- **现**: 每12小时自动运行 + 手动触发
  ```yaml
  schedule:
    - cron: '0 */12 * * *'  # 北京时间 0:00, 12:00
  ```

### GitHub Actions 优化
- **超时时间**: 60分钟 → 120分钟（给12小时运行充足时间）
- **运行频率**: 每天8次 → 每天2次（减少75%资源消耗）
- **成本优化**: 大幅减少GitHub Actions使用成本

### 测试配置优化

#### 阶段1: 连通性测试
| 参数 | 原值 | 新值 | 说明 |
|------|------|------|------|
| 并发数 | 6 | 8 | 参考SubsCheck标准，优化并发 |
| 超时时间 | 5秒 | 4秒 | 匹配SubsCheck标准 |
| 静默超时 | 45秒 | 60秒 | 合理缓冲时间 |

#### 阶段2: 媒体检测
| 参数 | 原值 | 新值 | 说明 |
|------|------|------|------|
| 并发数 | 3 | 5 | 适当提高并发 |
| 超时时间 | 8秒 | 10秒 | 匹配SubsCheck标准 |
| 媒体超时 | 15秒 | 10秒 | 匹配SubsCheck标准 |
| 静默超时 | 90秒 | 120秒 | 合理缓冲时间 |

## 🎯 预期效果

### 资源优化
- **运行次数**: 每天8次 → 每天2次 (-75%)
- **CPU时间**: 减少60-70%
- **网络流量**: 减少60-70%
- **成本控制**: 大幅降低GitHub Actions费用

### 稳定性提升
- **超时充裕**: 2小时总超时，给足夠时间
- **缓冲合理**: 60/120秒静默超时，避免误杀
- **配置标准**: 参考成熟工具的配置

### 用户体验
- **频率合理**: 每12小时更新一次，节点保持新鲜度
- **质量保证**: 保持自主测速的筛选优势
- **手动支持**: 保留手动触发功能用于紧急更新

## 🔧 技术实现

### GitHub Actions定时任务
```yaml
on:
  schedule:
    - cron: '0 */12 * * *'  # 每天0:00, 12:00
  workflow_dispatch:  # 手动触发
  workflow_run:      # 节点更新后触发
```

### 动态超时计算
```python
# 阶段1: 每8个节点4秒 + 1.5倍缓冲
base_time = (node_count / 8) * 4
timeout = int(base_time * 1.5)

# 阶段2: 每5个节点10秒 + 1.8倍缓冲  
base_time = (node_count / 5) * 10
timeout = int(base_time * 1.8)
```

## 📈 执行时间预估

| 节点数量 | 原始时间 | 12小时模式时间 | 节省时间 |
|----------|----------|----------------|----------|
| 500 | 25-30分钟 | 8-12分钟 | 50-60% |
| 1000 | 45-60分钟 | 15-20分钟 | 60-70% |
| 1500 | 60-90分钟 | 20-30分钟 | 65-70% |
| 2000 | 90-120分钟 | 25-35分钟 | 70-75% |

## 🚀 关键优势

1. **成本控制**: 大幅减少GitHub Actions使用
2. **质量保证**: 继续保持自主测速的优势
3. **频率合理**: 每12小时更新，节点新鲜度适中
4. **稳定性**: 充足的时间避免超时问题
5. **灵活性**: 保留手动触发用于特殊情况

## 📝 备注

- 北京时间 0:00, 12:00 = UTC 时间 16:00, 4:00
- 第一个节点更新: UTC 16:00 (北京时间 0:00)
- 第二个节点更新: UTC 4:00 (北京时间 12:00)
- 如需调整时间，修改cron表达式即可

这个策略既解决了资源消耗问题，又保持了项目的核心价值和完全自动化能力！